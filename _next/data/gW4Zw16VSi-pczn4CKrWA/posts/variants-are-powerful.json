{"pageProps":{"post":{"__typename":"Post","title":"Variants are incredibly powerful","slug":"variants-are-powerful","content":"Variants allow you to express that a value may be in more than one distinct states. Over the last years I have grown more fond of leveraging variants throughout my code to express the state that my program is in. Most programming languages support some form of variants, but are sometimes not given the time of day. For me personally, I often caught myself neglecting the usage of variants due to the verbosity of introducing additional types.\n\nA trivial example to start with is that we want to calculate the surface area of a geometric shape. In Typescript with an interface we could write something along the lines of:\n```typescript\ninterface GeometricShape {\n  getSurfaceArea(): number;\n}\nclass Square implements GeometricShape {\n  length: number;\n  constructor(length: number) {\n    this.length = length;\n  }\n  getSurfaceArea(): number {\n    return this.length * this.length;\n  }\n}\nclass RightTriangle implements GeometricShape {\n  a: number;\n  b: number;\n  constructor(a: number, b: number) {\n    this.a = a;\n    this.b = b;\n  }\n  getSurfaceArea(): number {\n    return (this.a * this.b) / 2;\n  }\n}\n```\nHowever, Typescript also supports polymorphism via variants as [discriminated unions](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions):\n```typescript\ntype square = {\n  type: \"square\";\n  length: number;\n};\ntype rightTriangle = {\n  type: \"rightTriangle\";\n  a: number;\n  b: number;\n};\ntype geometricShape = square | rightTriangle;\nfunction surfaceArea(shape: geometricShape): number {\n  switch (shape.type) {\n    case \"square\":\n      return shape.length * shape.length;\n    case \"rightTriangle\":\n      return (shape.a * shape.b) / 2;\n  }\n}\n```\nIf you take a second to think about the two ways to implement a function to compute the surface area, you will realize that users may interact very differently with the two APIs. In fact, I would consider the interface solution more powerful in this example: The user of the API is able to add more shapes, as long as it implements `GeometricShape`. However, the challenge lies in designing a good API that can be implemented by all classes.\n\nTo continue our example, let's consider that we added a new function `getAnglesOfShape(): Array<number>` that returns the angles of the shape. We can then use it to validate that the inner angles add up to 360.\n```typescript\ninterface GeometricShape {\n  getInteriorAngles(): Array<number>;\n}\nfunction validateShape(shape: GeometricShape) {\n  const angles = shape.getInteriorAngles();\n  let exteriorAngleSum = 0;\n  for (var angle of angles) {\n    exteriorAngleSum += 180 - angle;\n  }\n  return exteriorAngleSum == 360;\n}\n```\nUnfortunately, now a user attempted to implement a `Circle`, but struggles to implement `getAnglesOfShape`. It seemed like a perfectly reasonable method to add at the time, but now we found a shape that has infinitely many angles (or none?) and can't return a sensible result that can pass our validation. While a variant by itself can't save us, it simplifies our validationCode:\n```typescript\nfunction getInteriorAngles(shape: square | rightTriangle): Array<number> {\n  switch (shape.type) {\n    case \"square\":\n      return [90, 90, 90, 90];\n    case \"rightTriangle\":\n      const alpha = Math.atan(shape.a / shape.b);\n      return [alpha, 90 - alpha, 90];\n  }\n}\nfunction validateShape(shape: geometricShape) {\n  switch (shape.type) {\n    case \"circle\":\n      return true;\n    default:\n      const angles = getInteriorAngles(shape);\n      let exteriorAngleSum = 0;\n      for (var angle of angles) {\n        exteriorAngleSum += 180 - angle;\n      }\n      return exteriorAngleSum == 360;\n  }\n}\n```\nWhile we partially simply profit from restricting the user from implementing types, we can also note that we pushed the responsibility of handling the new shape to the consumer.\n\nI hope this gave you a little taste of why variants may be useful. One place where variants really start to shine is when writing finite state machines. For example, let's try to model a connection that automatically reconnects if it got disconnected. It's easy to express with a variant:\n```typescript\ninterface Request {}\ninterface Respoonse {}\ninterface Connection {\n  sendRequest(request: Request):\n    | {\n        status: \"sent\";\n        result: Promise<Response>;\n      }\n    | { status: \"notSent\" };\n}\ninterface ConnectionManager {\n  makeConnection(): Promise<Connection>;\n}\ntype connectionStatus =\n  | {\n      status: \"disconnected\";\n    }\n  | {\n      status: \"reconnecting\";\n      pending: Promise<Connection>;\n    }\n  | {\n      status: \"connected\";\n      connection: Connection;\n    };\nclass RetryingConnection {\n  currentConnection: connectionStatus;\n  manager: ConnectionManager;\n  constructor(manager: ConnectionManager) {\n    this.manager = manager;\n    this.currentConnection = {\n      status: \"disconnected\",\n    };\n  }\n  async sendRequest(request: Request): Promise<Response> {\n    let sentRequest;\n    do {\n      switch (this.currentConnection.status) {\n        case \"connected\":\n          sentRequest = this.currentConnection.connection.sendRequest(request);\n          break;\n        case \"disconnected\":\n          const pendingConnection = this.manager.makeConnection();\n          this.currentConnection = {\n            status: \"reconnecting\",\n            pending: pendingConnection,\n          };\n        case \"reconnecting\":\n          sentRequest = await this.currentConnection.pending.then(\n            (connection) => connection.sendRequest(request)\n          );\n      }\n      if (sentRequest.status == \"notSent\") {\n        this.currentConnection = {\n          status: \"disconnected\",\n        };\n      }\n    } while (sentRequest.status == \"notSent\");\n    return sentRequest.result;\n  }\n}\n```\nModeling the transitions between \"disconnected\", \"reconnecting\", and \"connected\" is simply not possible without variants.","date":"2021-11-24","ogImage":null,"coverImage":null,"author":{"__typename":"Author","name":"Nigel Schuster","slug":"nigel-schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}}},"moreStories":[{"__typename":"Post","title":"Systemd Services are frustratingly to make safe","slug":"systemd-frustration","excerpt":"This article takes a dive into what it takes to set up a systemd service with the principle of least privilege.","coverImage":null,"author":{"__typename":"Author","name":"Nigel Schuster","slug":"nigel-schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}}},{"__typename":"Post","title":"Avoiding generic types for safer code","slug":"avoid-generic-types","excerpt":"Using generic types like strings made me make mistakes on several occasion. There is a better way.","coverImage":null,"author":{"__typename":"Author","name":"Nigel Schuster","slug":"nigel-schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}}}],"__typename":"Query"},"__N_SSG":true}