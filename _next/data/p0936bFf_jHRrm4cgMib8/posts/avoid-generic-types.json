{"pageProps":{"__typename":"Query","moreStories":[{"__typename":"Post","author":{"__typename":"Author","name":"Nigel Schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}},"coverImage":null,"excerpt":"A good CSP can be a line of defence against XSS. It isn't trivial to get it right though.","slug":"how-to-csp","title":"How to CSP"},{"__typename":"Post","author":{"__typename":"Author","name":"Nigel Schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}},"coverImage":null,"excerpt":"Object destructuring makes it easier to ensure you use all fields and avoids dead code.","slug":"object-destructuring","title":"Why object destructuring is awesome"}],"post":{"__typename":"Post","author":{"__typename":"Author","name":"Nigel Schuster","picture":{"__typename":"Asset","url":"https://media.graphcms.com/resize=fit:crop,height:100,width:100/1bF1qLxsSbElgNK5x6t6"}},"content":"Generic types like `int` or `string` are quick and easy to use. However, sometimes they represent a specific concept. Declaring a new type is an easy way to avoid confusion. Let's look at the following code:\n```rust\npub fn rectangle_circumference(width: u32, height: u32) -> u32 {\n    2 * width + 2 * height\n}\n```\nThis code is meant to calculate the circumference of some arbitrary rectangle. It is simple and universally usable. However, it is very easy to use incorrectly. We have no guarantee that the units are all the same. `width` could be in centimeters, while `height` is in meters. To alleviate this problem, we can declare a specific type for a unit:\n```rust\npub struct Meter(pub u32);\npub fn rectangle_circumference(width: Meter, height: Meter) -> Meter {\n    Meter(2 * width.0 + 2 * height.0)\n}\n```\nWith this, we now put the burden on the caller to ensure that both inputs are of type `Meter`, and we guarantee that the output is of type `Meter` as well. At first sight, you may think that this incurs some overhead, however, the Godbolt output is the same for both versions when using `-C opt-level=3`:\n```x86asm\nexample::rectangle_circumference:\n        add     edi, esi\n        lea     eax, [rdi + rdi]\n        ret\n```\n\nOf course, we should consider making this more generic while maintaining precise types:\n```rust\npub trait LengthUnit {}\n\npub struct Rectangle<T: LengthUnit> {\n    width: T,\n    height: T,\n}\n\nimpl<T: LengthUnit> Rectangle<T>\nwhere\n    T: std::ops::Add<Output = T> + Copy,\n{\n    pub fn circumference(self) -> T {\n        let Rectangle { width, height } = self;\n        width + width + height + height\n    }\n}\n\n#[derive(Clone, Copy)]\nstruct Meter(u32);\nimpl LengthUnit for Meter {}\nimpl std::ops::Add for Meter {\n    type Output = Meter;\n    fn add(self, rhs: Self) -> Meter {\n        Meter(self.0 + rhs.0)\n    }\n}\npub fn rectangle_circumference<T>(width: T, height: T) -> T\nwhere\n    T: LengthUnit + Copy + std::ops::Add<Output = T>,\n{\n    (Rectangle { width, height }).circumference()\n}\n```\nAnd even this code compiles down to the same assembly in Gobolt when calling it with `Meter(u32)` input. \n\n### Bonus\nRust makes it particularly easy for us to deal with different units. You can design a `create` function for the rectangle to account for different types:\n```rust\nimpl<T: LengthUnit> Rectangle<T> {\n    pub fn create<W, H>(width: W, height: H) -> Self\n    where\n        W: std::convert::Into<T>,\n        H: std::convert::Into<T>,\n    {\n        Self {\n            width: width.into(),\n            height: height.into(),\n        }\n    }\n}\n```\nThis allows us to write the following program:\n```rust\n#[derive(Clone, Copy, Eq, PartialEq, Debug)]\nstruct Meter(u32);\n...\n#[derive(Clone, Copy)]\nstruct Centimeter(u32);\nimpl LengthUnit for Centimeter {}\nimpl std::convert::Into<Meter> for Centimeter {\n    fn into(self) -> Meter {\n        Meter(self.0 / 100)\n    }\n}\npub fn main() {\n    let width = Meter(3);\n    let height = Centimeter(300);\n    let circumference: Meter = (Rectangle::create(\n        width,\n        height,\n    ))\n    .circumference();\n    assert_eq!(circumference, Meter(12));\n}\n```","coverImage":null,"date":"2021-08-30","ogImage":null,"slug":"avoid-generic-types","title":"Avoiding generic types for safer code"}},"__N_SSG":true}